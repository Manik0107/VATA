# PRIMARY OUTPUT DIRECTIVE
Generate ONLY executable Python code for Manim Community v0.19+.

ABSOLUTE FORBIDDEN ELEMENTS:
‚ùå NEVER include ```python or ``` or any markdown code fences
‚ùå NEVER include [[ ## reasoning ## ]] or any section headers
‚ùå NEVER include explanatory text, comments outside code, or wrappers
‚ùå NEVER include JSON unless it's valid Python dictionary syntax
‚ùå NO markdown formatting whatsoever
‚ùå NEVER use vgroup.clear() - CRITICAL ERROR: VGroup has no clear() method!
‚ùå NEVER use self.label_group.clear() - VGroup AttributeError guaranteed!
‚ùå NEVER use ANY_VARIABLE.clear() if it's a VGroup - causes instant failure!
‚ùå NEVER use \max(lpha x, x) - LaTeX ERROR: Incomplete \alpha causes compilation failure!
‚ùå NEVER use pass statements in method bodies - FORBIDDEN: Every method needs full implementation!

MANDATORY OUTPUT FORMAT:
‚úÖ START immediately with: from manim import *
‚úÖ END with complete class definition
‚úÖ ONLY executable Python code
‚úÖ NO prefixes, suffixes, or explanations

# ADAPTIVE CORE PRINCIPLES
# - Self-Healing: If uncertain about any code section, use safe fallbacks
# - Graceful Degradation: Complex features can fall back to simpler equivalents
# - Future-Proof: Built-in compatibility checks and version-agnostic patterns
# - Creative Freedom: Core rules are enforced, but creative implementation is encouraged
# - Flexible Execution: Total minimum 150s runtime with natural pacing
# - If a helper method is referenced, always include its full definition (even if minimal) so the code runs without errors.
# - "Never end code mid-block‚Äîif in doubt, generate stubs for missing methods or complete the current method even if it means exceeding an internal line count. The absolute highest priority is syntactical completeness of the final generated block."
# ‚ö†Ô∏è  ABSOLUTELY CRITICAL: Never include ```python or ``` code fences in the output
# ‚ö†Ô∏è  OUTPUT STARTS WITH: from manim import * (NO MARKDOWN WRAPPER)
# ‚ö†Ô∏è  OUTPUT ENDS WITH: class definition completion (NO CLOSING FENCE)
# - Generate Manim code in scene classes or functions no longer than 500 lines each.
# - Stop code generation cleanly at logical boundaries such as end of methods or classes.

# MANDATORY FOUNDATION

# MANDATORY FOUNDATION
from manim import *
import numpy as np
import random
import os # Added for image path handling
from manim_voiceover import VoiceoverScene
# gTTS (manim_voiceover.services.gtts) is a simple, free, and cloud-based TTS engine.
# Ensure it's installed (pip install gTTS manim-voiceover[gtts]).
from manim_voiceover.services.gtts import GTTSService 

# Safety helpers (always include these)
def to3(p):
    p = np.array(p, dtype=float).reshape(-1)
    if p.shape[0] == 2: return np.array([p[0], p[1], 0.0])
    if p.shape[0] == 3: return p.astype(float)
    return np.array([p[0], p[1], 0.0]) if len(p) >= 2 else np.array([0.0, 0.0, 0.0])

def to3Nx(points):
    arr = np.array(points, dtype=float)
    if arr.ndim == 1: return to3(arr).reshape(1, 3)
    if arr.ndim == 2:
        if arr.shape[1] >= 2:
            if arr.shape[1] == 2:
                return np.hstack([arr, np.zeros((arr.shape[0], 1))])
            return arr[:, :3] if arr.shape[1] >= 3 else arr
    return np.array([[0.0, 0.0, 0.0]])

# CRITICAL IMPORT SAFETY - Always include all required colors and objects
from manim import BLUE, RED, GREEN, GOLD, YELLOW, WHITE, GREY_B, GREY_C, PURPLE, PINK, ORANGE, TEAL, BLACK

def safe_color(c, fallback=BLUE):
    valid_colors = [BLUE, RED, GREEN, GOLD, YELLOW, WHITE, GREY_B, GREY_C, PURPLE, PINK, ORANGE, TEAL, BLACK]
    if c in valid_colors: return c
    if isinstance(c, (tuple, list)) and len(c) >= 3: return tuple(float(v) for v in c[:3])
    return fallback

# MANIM v0.19+ POSITIONING HELPERS (Always include these)
def safe_position_above(obj, distance=1.5):
    """Safe positioning above an object - v0.19+ compatible"""
    return obj.get_center() + UP * distance

def safe_position_below(obj, distance=1.5):
    """Safe positioning below an object - v0.19+ compatible"""
    return obj.get_center() + DOWN * distance

def safe_position_left(obj, distance=2):
    """Safe positioning to the left of an object - v0.19+ compatible"""
    return obj.get_center() + LEFT * distance

def safe_position_right(obj, distance=2):
    """Safe positioning to the right of an object - v0.19+ compatible"""
    return obj.get_center() + RIGHT * distance

def create_text_around_object(text_content, obj, direction="above", font_size=20):
    """Create text positioned around an object safely - v0.19+ compatible"""
    text_obj = Text(text_content, font_size=font_size)
    
    if direction == "above":
        text_obj.next_to(obj, UP, buff=0.5)
    elif direction == "below":
        text_obj.next_to(obj, DOWN, buff=0.5)
    elif direction == "left":
        text_obj.next_to(obj, LEFT, buff=0.5)
    elif direction == "right":
        text_obj.next_to(obj, RIGHT, buff=0.5)
    else:
        text_obj.move_to(obj.get_center() + UP * 1.5)
    
    return text_obj


# MANIM v0.19+ API COMPLIANCE - CRITICAL RULES

## POSITIONING (NEVER USE DEPRECATED METHODS)
# ‚ùå FORBIDDEN: .get_above(), .get_below(), .get_left(), .get_right(), .get_center()
# ‚úÖ CORRECT: Use .get_top(), .get_bottom(), .get_left(), .get_right(), .get_center()
# ‚úÖ BETTER: Use direct positioning: UP, DOWN, LEFT, RIGHT, ORIGIN
# ‚úÖ BEST: Use .next_to(), .move_to(), .shift(), .to_edge(), .to_corner()

## SAFE POSITIONING PATTERNS
# Instead of: obj.get_above() + UP
# Use: obj.get_top() + UP or better: obj.get_center() + UP*2

def safe_position_above(obj, distance=1):
    return obj.get_center() + UP * distance

def safe_position_below(obj, distance=1):
    return obj.get_center() + DOWN * distance

def safe_position_left(obj, distance=1):
    return obj.get_center() + LEFT * distance

def safe_position_right(obj, distance=1):
    return obj.get_center() + RIGHT * distance

## LaTeX & Text Rules (v0.19+ Compatible)
# - Primary: Use MathTex(r"formula") with raw strings
# - Fallback: Use Text("formula") if LaTeX compilation fails
# - Greek Letters: LaTeX commands (\theta, \alpha) preferred, but Unicode acceptable as fallback
# - Braces: Single braces preferred {}, double braces {{}} acceptable if needed
# - Indexing: Create separate MathTex objects instead of indexing when possible

## Animation API (v0.19+ Only)
# - REQUIRED: Create, Write, FadeIn, FadeOut, Transform, ReplacementTransform, Indicate, Flash
# - FORBIDDEN: DrawBorderThenFill, ShowCreation, ShowIncreasingSubsets (deprecated)
# - Safe animation pattern:
def safe_create_animation(obj):
    try:
        return Create(obj)
    except:
        return FadeIn(obj)  # Fallback

# IMAGE INTEGRATION REQUIREMENTS

# When generating Manim code, automatically include relevant images from the extracted PDF:

## Image Display Rules:
# Use ImageMobject to load and display images from the images folder
# Display images when explaining concepts that have corresponding visual aids
# Position images appropriately (right side, corner, or center based on content)
# Scale images to fit within the scene without overlapping text
# Use FadeIn/FadeOut animations for smooth image transitions

## Image Integration Pattern:
# CRITICAL: Always include try/except blocks around ImageMobject creation to handle missing or corrupted image files gracefully.
def load_image_safe(self, image_path, scale=0.5, position=RIGHT*3):
    try:
        # Ensure image_path is correctly formed. Assuming image_path might be 'output/document_images/image_1.png'
        # or just 'image_1.png' if images_folder is prepended.
        # This helper should accept a full path, or you handle folder prefix outside.
        img = ImageMobject(image_path)
        img.scale(scale)
        img.move_to(position)
        return img
    except Exception as e:
        # Fallback: create a placeholder rectangle
        print(f"Warning: Could not load image {image_path}. Error: {e}. Using placeholder.")
        placeholder = Rectangle(width=2, height=1.5, color=GREY_B).move_to(position)
        text = Text("Image", font_size=24).move_to(position)
        return Group(placeholder, text)

## Image-Content Matching:
# Check the metadata JSON for image context and keywords
# Display images when explaining topics that match the image keywords
# For graphs/charts: show during data analysis or results sections
# For formulas: display during mathematical derivations
# For diagrams: show during concept explanations

## Required Image Processing:
# Use the image metadata from {metadata} to determine:
# 1. Which images to show and when
# 2. What type of content each image represents
# 3. How to position and scale each image appropriately
# 4. What explanatory text should accompany each image

# CRITICAL: Always include try/except blocks around ImageMobject creation to handle missing or corrupted image files gracefully.

## Coordinate System (Universal)
# - All coordinates: Use helper functions to3() and to3Nx()
# - Auto-correction: Functions handle 2D inputs gracefully
# - Fallback: Default to ORIGIN if coordinate conversion fails

# ================= SYNC & PACE FIX =================
# Voiceover & Video Sync Enhancements

# 1. Automatic Duration Adjustment:
#    - Ensure animations fully match the voiceover duration.
#    - If audio is shorter than the animation, animation waits until audio finishes.
#    - If audio is longer than animation, extend animation to match audio duration.
#    - Use the following pattern inside each voiceover block:

#    with self.voiceover(text="Narration text") as tracker:
#        anim = SomeAnimation(obj)
#        self.play(anim, run_time=max(anim.runtime, tracker.duration))
#        # Optional: wait remaining time if animation ended early
#        if tracker.duration > anim.runtime:
#            self.wait(tracker.duration - anim.runtime)

# 2. Default Animation Speeds:
#    - Avoid using fixed run_time values like 1 or 2 seconds.
#    - Always use dynamic pacing:
#        run_time = tracker.duration * scaling_factor
#    - scaling_factor ~ 1.0-1.2 ensures animation completes slightly before audio ends.

# 3. Ensure Audio Always Plays:
#    - Wrap all visual sequences in `with self.voiceover(...)` blocks.
#    - Do not place animations outside voiceover blocks if narration is required.
#    - Use `self.wait()` after each voiceover block to avoid skipping audio.

# 4. Safe Fallback for Missing Audio:
#    - If GTTS fails for any segment, insert `tracker.duration = estimated_duration`
#    - Prevents animations from stalling or running too fast.

# 5. Optional Pace Optimization:
#    - For long explanatory text, split into multiple shorter voiceover blocks.
#    - Example:
#        with self.voiceover(text="First part of narration") as tracker1:
#            self.play(FadeIn(obj1), run_time=tracker1.duration)
#        with self.voiceover(text="Second part") as tracker2:
#            self.play(FadeIn(obj2), run_time=tracker2.duration)
#    - This ensures proper pacing and keeps audio synchronized.

# CRITICAL NARRATION RULES - NO SPOKEN PAUSE MARKERS:
# ‚ùå FORBIDDEN: Using [PAUSE], [BREAK], or similar markers in narration text
# ‚úÖ CORRECT: Split narration into separate voiceover blocks for natural pauses
# ‚úÖ BETTER: Use punctuation (periods, commas, ellipses) for natural speech rhythm
# ‚úÖ BEST: Use self.wait() between voiceover blocks for controlled timing

## NARRATION BEST PRACTICES:
# 1. Split Long Narration - Break complex explanations into digestible chunks:
#    with self.voiceover(text="The encoder stack is made up of multiple identical layers.") as tracker:
#        self.play(FadeIn(layer_stack), run_time=tracker.duration)
#    self.wait(0.8)  # Natural pause
#    with self.voiceover(text="Each layer contains multi-head self-attention, feed-forward network, residual connections, and layer normalization.") as tracker:
#        self.play(Indicate(components), run_time=tracker.duration)

# 2. Natural Speech Rhythm - Use punctuation for pacing:
#    "First concept... Now, let's explore the second concept."
#    "This is important: key insight here."
#    "We can see that, clearly, this demonstrates our point."

# 3. Avoid Robotic Speech - Instead of markers, use natural language:
#    ‚ùå "This is the formula. [PAUSE] Now we apply it."
#    ‚úÖ "This is the formula. Now, let's see how we apply it in practice."

# 4. Coordinated Visual-Audio Timing:
#    with self.voiceover(text="Let's examine each component individually.") as tracker:
#        # Show overview first
#        self.play(FadeIn(overview), run_time=tracker.duration * 0.3)
#        self.wait(tracker.duration * 0.7)  # Let narration finish
#    
#    with self.voiceover(text="First, we have the attention mechanism.") as tracker:
#        # Then highlight specific component
#        self.play(Indicate(attention_part), run_time=tracker.duration)

# 6. Recommended Template Change for All Methods:
#    - Replace all `self.play(..., run_time=tracker.duration)` with:
#        actual_run_time = max(getattr(anim, "runtime", 0), tracker.duration)
#        self.play(anim, run_time=actual_run_time)
#        if tracker.duration > actual_run_time:
#            self.wait(tracker.duration - actual_run_time)
#    - Guarantees animation completion while syncing perfectly with audio.

ZERO-TOLERANCE OUTPUT RULES:

INSTANT REJECTION TRIGGERS:
‚ùå ```python (any code fence)
‚ùå ``` (fence closing)
‚ùå [[ ## header ## ]] (section markers)
‚ùå # ANALYSIS or ## STEP (header sections)
‚ùå "Here's the code" (explanatory text)
‚ùå JSON unless Python dict syntax
‚ùå Any markdown formatting
‚ùå Text before "from manim import *"
‚ùå Text after class definition ends

REQUIREMENTS FOR ACCEPTANCE:
1. Output ONLY Python code - zero exceptions
2. Start immediately with "from manim import *" 
3. End with complete class definition
4. Valid .py file ready to run
5. One class inheriting from VoiceoverScene
6. Must contain construct method with GTTSService
7. Complete implementation, no truncation

‚ö†Ô∏è  EXACT TEMPLATE FORMAT (NO FENCES):

from manim import *
from manim_voiceover import VoiceoverScene
from manim_voiceover.services.gtts import GTTSService

class GeneratedScene(VoiceoverScene):
    def construct(self):
        self.set_speech_service(GTTSService())

        with self.voiceover("... your narration here ...") as tracker:
            # animations go here

        self.wait(2)

# ADAPTIVE STRUCTURE TEMPLATE
# NEW MANIM VOICEOVER INTEGRATION RULES:
# 1. Always inherit from VoiceoverScene (from manim_voiceover).
# 2. Always set a speech service at the beginning of construct using GTTSService.
#    gTTS is a free, cloud-based TTS engine. Ensure it's installed (pip install gTTS manim-voiceover[gtts]).
# 3. Enclose every logical visual block or narration segment within a `with self.voiceover(text="Your narration text here.") as tracker:` block.
# 4. Inside a voiceover block, ensure animations use `run_time=tracker.duration` where appropriate.
#    If an animation is shorter than the narration, the system will automatically `wait` until the voiceover finishes.
#    If an animation needs to be *longer* than the narration, you must explicitly set a `run_time` greater than `tracker.duration`
#    or add a `self.wait()` after the animation within the voiceover block.
# 5. Keep the code clean, modular, and easy to read.

class GeneratedEducationalScene(VoiceoverScene):
    def construct(self):
        # Set speech service to GTTSService for free, cloud-based TTS.
        # Ensure you have installed it: pip install gTTS manim-voiceover[gtts]
        self.set_speech_service(GTTSService()) 

        print("Sanity:", isinstance(BLUE, type(WHITE)), "colors OK")
        
        try: self.show_introduction()
        except Exception as e: print(f"Error in show_introduction: {e}")
        
        try: self.explain_core_concepts()
        except Exception as e: print(f"Error in explain_core_concepts: {e}")
        
        try: self.show_mathematical_derivation() 
        except Exception as e: print(f"Error in show_mathematical_derivation: {e}")
        
        try: self.demonstrate_examples()
        except Exception as e: print(f"Error in demonstrate_examples: {e}")
        
        try: self.highlight_applications()
        except Exception as e: print(f"Error in highlight_applications: {e}")
        
        try: self.summarize_key_points()
        except Exception as e: print(f"Error in summarize_key_points: {e}")
    
    # Implement relevant methods based on topic complexity
    def show_introduction(self):
        # Example of voiceover block usage
        with self.voiceover(text="Welcome to this lesson. We will explore key concepts today.") as tracker:
            title = Title("Introduction to Topic")
            self.play(Write(title), run_time=tracker.duration)
            self.wait(0.5) # Small optional pause for natural pacing
        
        with self.voiceover(text="Our journey will cover several important areas.") as tracker:
            intro_text = Text("Understanding key ideas", font_size=36).next_to(title, DOWN)
            self.play(FadeIn(intro_text), run_time=tracker.duration)
            self.wait(0.5)
            
        # Ensure all methods have at least a pass or self.wait() to prevent ending mid-block
        self.wait(1)

    def explain_core_concepts(self):
        # Placeholder for core concepts explanation
        with self.voiceover(text="Now, let's delve into the core concepts.") as tracker:
            concept_title = Text("Core Concepts", font_size=48).to_edge(UP)
            self.play(Transform(self.mobjects[0], concept_title), run_time=tracker.duration)
        self.wait(1)
    
    def show_mathematical_derivation(self):
        # Placeholder for mathematical derivation
        with self.voiceover(text="We will now explore the mathematical underpinnings.") as tracker:
            math_text = MathTex(r"\sum_{i=1}^{n} x_i", font_size=72).move_to(ORIGIN)
            self.play(FadeIn(math_text), run_time=tracker.duration)
        self.wait(1)

    def demonstrate_examples(self):
        # Placeholder for demonstrating examples
        with self.voiceover(text="Let's look at some practical examples to solidify our understanding.") as tracker:
            example_text = Text("Example 1", font_size=48).to_edge(UP)
            self.play(Transform(self.mobjects[0], example_text), run_time=tracker.duration)
        self.wait(1)

    def highlight_applications(self):
        # Placeholder for highlighting applications
        with self.voiceover(text="These concepts have wide-ranging applications in various fields.") as tracker:
            app_text = Text("Real-world Applications", font_size=48).to_edge(UP)
            self.play(Transform(self.mobjects[0], app_text), run_time=tracker.duration)
        self.wait(1)

    def summarize_key_points(self):
        # Placeholder for summarizing key points
        with self.voiceover(text="To conclude, let's review the most important takeaways from this lesson.") as tracker:
            summary_text = Text("Key Takeaways", font_size=48).to_edge(UP)
            self.play(Transform(self.mobjects[0], summary_text), run_time=tracker.duration)
        self.wait(2)


# CONTENT ADAPTATION FRAMEWORK

## For Simple Topics
# - Focus on visual clarity and basic animations
# - Use straightforward mathematical notation
# - Emphasize intuitive explanations

## For Complex Topics
# - Implement full derivation chains
# - Use advanced animation techniques
# - Include multiple worked examples
# - Add comparative analysis sections

## For Any Topic
# - Runtime Management: Use strategic self.wait() placement
# - Visual Hierarchy: Clear title/subtitle positioning
# - Progressive Disclosure: Reveal concepts step-by-step
# - Error Recovery: Graceful handling of edge cases

# MATHEMATICAL CONTENT PATTERNS

## Safe Scatter Plot Pattern
def create_safe_scatter(self, x_data, y_data, color=YELLOW):
    try:
        x_arr = np.array(x_data, dtype=float)
        y_arr = np.array(y_data, dtype=float)
        points = to3Nx(np.column_stack([x_arr, y_arr]))
        return VGroup(*[Dot(point=p, color=safe_color(color), radius=0.04) for p in points])
    except:
        # Fallback: simple demonstration points
        return VGroup(*[Dot(np.array([i, i, 0]), color=safe_color(color)) for i in range(3)])

## Safe Regression Line Pattern
def create_safe_line(self, axes, slope, intercept, color=GREEN):
    try:
        line = axes.plot(lambda x: slope*x + intercept, color=safe_color(color))
        return line
    except:
        # Manual line fallback
        p1 = to3([axes.x_range[0], slope*axes.x_range[0] + intercept])
        p2 = to3([axes.x_range[1], slope*axes.x_range[1] + intercept])
        return Line(p1, p2, color=safe_color(color))

# CREATIVE FLEXIBILITY ZONES

## Encouraged Creativity
# - Visual Metaphors: Use creative analogies and representations
# - Animation Styles: Experiment with timing and transitions
# - Color Schemes: Choose aesthetically pleasing palettes
# - Layout Design: Arrange elements for maximum clarity
# - Narrative Flow: Adapt story structure to content

## Creative Safety Rails
# - All objects must be positioned to avoid overlaps
# - Mathematical content must be accurate
# - Runtime must meet minimum requirements
# - Core educational goals must be addressed

# AUTO-UPDATING COMPATIBILITY

## Version Adaptability
# Auto-detect and adapt to API changes
def safe_axes_creation(self, x_range, y_range, **kwargs):
    try:
        # Attempt to use the v0.19+ Axes constructor
        axes = Axes(x_range=x_range, y_range=y_range, **kwargs)
        axes.move_to(ORIGIN)
        return axes
    except TypeError:
        # Fallback for older versions or different API if kwargs are an issue
        # Re-attempt without specific kwargs or with a different constructor pattern
        # This part might need further refinement based on specific older Manim APIs
        axes = Axes(x_range=x_range, y_range=y_range)
        axes.shift_to_origin()
        return axes
    except Exception as e:
        # Generic fallback if anything else fails
        print(f"Error creating axes, using generic fallback: {e}")
        axes = Axes() # Default axes
        axes.shift_to_origin()
        return axes

## Future-Proof Patterns
# - Use feature detection instead of version checking
# - Implement graceful fallbacks for new/changed APIs
# - Maintain backward compatibility where possible

# INPUT INTEGRATION DIRECTIVES

# Primary Content: {query}
# Reference Material: {document_content}
# Metadata Context: {metadata}
# Visual Assets: {images}

# Adaptive Processing:
# - Extract key concepts from all input sources
# - Prioritize user query requirements
# - Integrate document details where relevant
# - Reference metadata for context
# - Include image assets if applicable

# FINAL VALIDATION (AUTO-CORRECTING)

## Self-Checking Mechanisms
# - Syntax validation with error recovery
# - Coordinate system verification
# - Color compatibility checking
# - Runtime calculation
# - Mathematical accuracy review

## Auto-Correction Features
# - Invalid colors ‚Üí safe_color() replacement
# - 2D coordinates ‚Üí to3() conversion
# - Missing methods ‚Üí safe fallback implementation
# - API changes ‚Üí compatibility layer activation

# DELIVERABLE SPECIFICATION

# Generate a complete, immediately executable Manim script that:

# 1. Runs Successfully: No syntax errors, all methods are fully implemented or appropriately stubbed, complete implementation.
# 2. Adapts Gracefully: Handles edge cases and API variations
# 3. Teaches Effectively: Clear educational progression and visual design
# 4. Performs Robustly: 150+ second runtime with proper pacing
# 5. Updates Seamlessly: Compatible with current and future Manim versions

## CRITICAL COMPLETION GUARANTEE - NO INCOMPLETE IMPLEMENTATIONS
üö® ABSOLUTELY FORBIDDEN - INCOMPLETE IMPLEMENTATIONS:
‚ùå NEVER use pass statements in method bodies
‚ùå NEVER use placeholder comments like "# ... (Implementation)"
‚ùå NEVER leave methods with empty bodies
‚ùå NEVER use "# TODO: Implement this method"
‚ùå NEVER generate stub methods without full implementation

‚úÖ MANDATORY: EVERY method must have COMPLETE implementation with:
‚úÖ Actual Manim objects (Text, Circle, Rectangle, etc.)
‚úÖ Real animations (Create, FadeIn, Transform, etc.) 
‚úÖ Proper voiceover blocks with self.voiceover(text="...")
‚úÖ Timing with tracker.duration or self.wait()
‚úÖ Full scene cleanup and transitions
‚úÖ Educational content that matches the method name

## EXAMPLE - COMPLETE METHOD IMPLEMENTATION TEMPLATE:
def attention_analogy(self):
    with self.voiceover(text="Think of attention like a searchlight. When you're looking for something specific, you focus more on relevant areas.") as tracker:
        # Create visual elements
        searchlight = Circle(radius=0.5, color=YELLOW, fill_opacity=0.3)
        target_objects = VGroup(*[Rectangle(width=0.5, height=0.5, color=BLUE).shift(UP*i + RIGHT*j) 
                                for i in range(-2, 3) for j in range(-3, 4)])
        
        # Animate the scene
        self.play(Create(target_objects), run_time=tracker.duration * 0.3)
        self.play(Create(searchlight), run_time=tracker.duration * 0.2)
        
        # Add labels
        self.labeler.create_smart_label(searchlight, "Attention Focus")
        self.play(self.labeler.animate_labels_in())
        
        # Move searchlight to demonstrate attention
        for obj in target_objects[:3]:
            self.play(searchlight.animate.move_to(obj.get_center()), run_time=0.5)
            
        self.wait(tracker.duration * 0.5)
        
    # Cleanup
    self.play(FadeOut(VGroup(searchlight, target_objects)))
    self.labeler.clear_labels()

## METHOD IMPLEMENTATION REQUIREMENTS - ZERO TOLERANCE:
üö® If a method is named "linear_algebra_review", it MUST contain:
‚úÖ Vector visualizations (Arrow, Line objects)  
‚úÖ Matrix representations (Rectangle grids)
‚úÖ Mathematical formulas (MathTex objects)
‚úÖ Educational narration explaining linear algebra concepts

üö® If a method is named "dot_product", it MUST contain:
‚úÖ Vector dot product visualization
‚úÖ Mathematical formula: MathTex(r"\\vec{a} \\cdot \\vec{b} = |a||b|\\cos\\theta")
‚úÖ Animated calculation steps
‚úÖ Geometric interpretation

üö® If a method is named "attention_analogy", it MUST contain:
‚úÖ Visual analogy (searchlight, spotlight, focus mechanism)
‚úÖ Interactive demonstration
‚úÖ Clear educational explanation of attention concept

## GENERAL RULE: Method name = Implementation content. No exceptions.

# Output Format: Pure Python code only‚ÄîNO EXPLANATORY TEXT, NO MARKDOWN, NO CODE BLOCKS.
# ‚ö†Ô∏è  CRITICAL: Output must start with "from manim import *" - NO ```python wrapper

# ZERO ERROR GUARANTEE - MANIM v0.19+ COMPLIANCE

## CRITICAL ERROR PREVENTION RULES (Based on Common Failures):

### 1. Animation Creation - NEVER Pass Multiple Objects to Create()
```python
# ‚ùå WRONG: Multiple positional arguments to Create()
self.play(Create(obj1, obj2, obj3, obj4, obj5, obj6))

# ‚úÖ CORRECT: Single argument or VGroup
self.play(Create(VGroup(obj1, obj2, obj3, obj4, obj5, obj6)))
# OR
all_objects = VGroup(obj1, obj2, obj3, obj4, obj5, obj6)
self.play(Create(all_objects))
```

### 2. Axes Coordinate Labels - NEVER use add_coordinate_labels()
```python
# ‚ùå WRONG: add_coordinate_labels() doesn't exist
axes.add_coordinate_labels()

# ‚úÖ CORRECT: Use get_axis_labels()
axes_labels = axes.get_axis_labels(x_label="x", y_label="f(x)")
self.play(Create(axes), Create(axes_labels))
```

### 3. Table Construction - Handle Type Consistency
```python
# ‚ùå WRONG: Mixed Text objects and strings
table = Table([
    [Text("A"), Text("B")],
    ["String1", "String2"]  # This causes TypeError
])

# ‚úÖ CORRECT: Convert all to strings with element_to_mobject
table_data = [
    ["Simple, Efficient", "Dying ReLU Problem"],
    ["Prevents Dying ReLU", "Requires Tuning 'a'"]
]

table = Table(
    table_data,
    row_labels=[Text("ReLU", font_size=20), Text("Leaky ReLU", font_size=20)],
    col_labels=[Text("Advantages", font_size=20), Text("Disadvantages", font_size=20)],
    include_outer_lines=True,
    element_to_mobject=lambda s: Text(s, font_size=20)  # Convert strings to Text
)
```

### 4. VGroup Type Safety - Only VMobjects
```python
# ‚ùå WRONG: Adding non-VMobject to VGroup
vgroup = VGroup()
vgroup.add("string")  # Causes TypeError

# ‚úÖ CORRECT: Only add VMobjects
text_obj = Text("string")
vgroup = VGroup(text_obj)
```

### 5. Table Highlighting - Use add_highlighted_cell()
```python
# ‚ùå WRONG: get_entries_in_row() with set_color()
table.get_entries_in_row(1).set_color(GREEN)

# ‚úÖ CORRECT: Use add_highlighted_cell()
table.add_highlighted_cell((1,1), color=GREEN)  # (row, col) indexing
table.add_highlighted_cell((1,2), color=RED)
```

### 6. Fill Operations - Always Include Opacity
```python
# ‚ùå WRONG: Missing opacity parameter
neuron.animate.set_fill(color=GREY_B)

# ‚úÖ CORRECT: Include opacity
neuron.animate.set_fill(color=GREY_B, opacity=1)
```

### 7. Scene Cleanup Patterns - Guard All Operations
```python
# ‚úÖ ALWAYS: Clear scene before new content
def new_scene_method(self):
    if self.mobjects:
        self.clear()
    # ... rest of method

# ‚úÖ ALWAYS: Guard cleanup operations
if self.scene_elements:
    self.play(FadeOut(self.scene_elements))
```

## MANDATORY ERROR PREVENTION RULES:
1. **NEVER use deprecated positioning methods**: .get_above(), .get_below() are FORBIDDEN
2. **ALWAYS use modern positioning**: .get_center(), .get_top(), .get_bottom(), .get_left(), .get_right()
3. **PREFER relative positioning**: .next_to(other_obj, direction), .move_to(position)
4. **USE constants for directions**: UP, DOWN, LEFT, RIGHT, UL, UR, DL, DR
5. **WRAP risky operations in try/except blocks**
6. **ALWAYS use VGroup for multiple objects in animations**
7. **NEVER pass multiple objects directly to Create()**
8. **ALWAYS use get_axis_labels() instead of add_coordinate_labels()**
9. **ALWAYS use element_to_mobject for Table construction**
10. **ALWAYS guard cleanup operations with existence checks**

## POSITIONING REPLACEMENT GUIDE:
# OLD (FORBIDDEN) ‚Üí NEW (REQUIRED)
# obj.get_above() ‚Üí obj.get_center() + UP*1.5
# obj.get_below() ‚Üí obj.get_center() + DOWN*1.5  
# obj.get_left() ‚Üí obj.get_center() + LEFT*2
# obj.get_right() ‚Üí obj.get_center() + RIGHT*2

## SAFE POSITIONING TEMPLATE:
def position_text_around_object(self, obj, text_content, direction="above"):
    text_obj = Text(text_content, font_size=20)
    
    if direction == "above":
        text_obj.next_to(obj, UP, buff=0.5)
    elif direction == "below":
        text_obj.next_to(obj, DOWN, buff=0.5)
    elif direction == "left":
        text_obj.next_to(obj, LEFT, buff=0.5)
    elif direction == "right":
        text_obj.next_to(obj, RIGHT, buff=0.5)
    
    return text_obj

## UNIVERSAL LABELING SYSTEM - MANDATORY CORRECT TEMPLATE
class UniversalLabelingSystem:
    def __init__(self, scene):
        self.scene = scene
        self.label_group = VGroup()
    
    def clear_labels(self):
        """CORRECT way to clear labels - NEVER use .clear()"""
        # ‚ùå NEVER: self.label_group.clear()  
        # ‚úÖ ALWAYS use this exact pattern:
        for mobject in list(self.label_group.submobjects):
            self.label_group.remove(mobject)

## MANDATORY CODE STRUCTURE TEMPLATE (NO CODE FENCES IN OUTPUT):

STRICT OUTPUT VALIDATION:

FORBIDDEN PATTERNS (will cause rejection):
‚ùå ```python (markdown fence start)
‚ùå ``` (markdown fence end)
‚ùå [[ ## title ## ]] (section headers)
‚ùå # REASONING: (header sections)  
‚ùå ## STEP 1 (markdown headers)
‚ùå JSON: { "key": "value" } (unless Python dict)
‚ùå Here's the code: (explanatory text)
‚ùå The solution is: (explanatory text)

REQUIRED START PATTERN:
from manim import *
from manim_voiceover import VoiceoverScene  
from manim_voiceover.services.gtts import GTTSService

class YourClassName(VoiceoverScene):
    def construct(self):
        self.set_speech_service(GTTSService())
        
        # Call all scene methods
        self.method1()
        self.method2()
        
        self.wait(2)
    
    def method1(self):
        # Always clear at start
        if self.mobjects:
            self.clear()
            
        with self.voiceover(text="Your narration here") as tracker:
            # Create elements
            element1 = SomeObject()
            element2 = SomeObject()
            all_elements = VGroup(element1, element2)
            
            # Animate with timing (NEVER multiple objects to Create)
            self.play(Create(all_elements), run_time=tracker.duration * 0.5)
            self.wait(tracker.duration * 0.5)
            
            # Cleanup with guard
            if all_elements:
                self.play(FadeOut(all_elements))

# CRITICAL COMPLETION GUARANTEE: The generated code MUST be a fully closed and executable Python file.
# If you are generating a class method, ensure it concludes with self.wait() or self.play() and is properly indented and terminated before the generation stops.
# Do not terminate mid-statement, mid-line, or mid-method body. The final output must be syntactically valid Python.

# UNIVERSAL LABELING SYSTEM ERROR PREVENTION

## CRITICAL NUMPY ARRAY COMPARISON FIX
‚ùå WRONG: Direct comparison with direction constants
if direction == UP:  # This causes "truth value ambiguous" error

‚úÖ CORRECT: Use numpy array comparison
if np.array_equal(direction, UP):
    label.next_to(obj, UP, buff=buff)

## VGROUP METHOD CORRECTIONS - CRITICAL ERROR PREVENTION
üö® CRITICAL: VGroup has NO .clear() method - NEVER use ANY form of .clear()
‚ùå FORBIDDEN PATTERNS - WILL CAUSE AttributeError:
vgroup.clear()  # AttributeError: VGroup object has no attribute 'clear'
self.label_group.clear()  # NEVER use this in UniversalLabelingSystem
labels.clear()  # NEVER use this for any VGroup variable
group.clear()  # NEVER use this for any VGroup variable
any_vgroup_name.clear()  # NEVER use .clear() on ANY VGroup

‚úÖ CORRECT METHOD 1 - Remove all submobjects manually:
for mobject in list(vgroup.submobjects):
    vgroup.remove(mobject)

‚úÖ CORRECT METHOD 2 - Create new VGroup instance:
vgroup = VGroup()  # Replace the old VGroup entirely

‚úÖ CORRECT METHOD 3 - Use conditional clearing:
if hasattr(vgroup, 'submobjects') and vgroup.submobjects:
    for mobject in list(vgroup.submobjects):
        vgroup.remove(mobject)

## SPECIFIC UNIVERSAL LABELING SYSTEM PATTERN
def clear_labels(self):
    """Clear all labels from the scene."""
    # ‚ùå NEVER: self.label_group.clear()
    # ‚úÖ ALWAYS use this pattern:
    for mobject in list(self.label_group.submobjects):
        self.label_group.remove(mobject)

## MANDATORY VGroup USAGE RULES
- NEVER call .clear() on ANY VGroup variable (vgroup, label_group, labels, group, etc.)
- Always use VGroup.add() to add objects  
- Always use VGroup.remove() to remove specific objects
- Use list(vgroup.submobjects) to avoid iteration modification issues
- In clear_labels() methods, ALWAYS use the manual removal pattern
- Remember: VGroup does NOT inherit from Python lists - it has no .clear() method

## LATEX COMPILATION ERROR PREVENTION - CRITICAL MANIM REQUIREMENT
üö® LATEX ERRORS CAUSE ANIMATION FAILURE - PREVENT AT ALL COSTS

‚ùå FORBIDDEN LaTeX PATTERNS THAT CAUSE COMPILATION ERRORS:
- \max(lpha x, x)  # Missing \a in \alpha - CAUSES IMMEDIATE ERROR  
- \max(\alpha x x)  # Missing comma between arguments
- \max(\alpha x,)  # Trailing comma without second argument
- \alphax  # Missing space after \alpha  
- \max(\a x, x)  # Incomplete \alpha command
- \max(alpha x, x)  # Missing backslash before alpha
- \max(\alpha, x, y)  # Too many arguments for \max
- \max(\alpha  x, x)  # Extra spaces can cause issues
- \max{\alpha x, x}  # Wrong brackets - use parentheses
- \max[\alpha x, x]  # Wrong brackets - use parentheses

‚úÖ CORRECT LaTeX PATTERNS - GUARANTEED TO WORK:
- MathTex(r"f(x) = \max(\alpha x, x)")  # Correct Leaky ReLU formula
- MathTex(r"f(x) = \max(0, x)")  # Correct ReLU formula  
- MathTex(r"f(x) = \begin{cases} x & \text{if } x > 0 \\ \alpha x & \text{otherwise} \end{cases}")
- MathTex(r"\alpha = 0.01")  # Parameter definition
- MathTex(r"f'(x) = \begin{cases} 1 & \text{if } x > 0 \\ \alpha & \text{otherwise} \end{cases}")

## MANDATORY LaTeX VALIDATION RULES FOR MathTex/Tex OBJECTS:
‚úì Always use raw strings with r"..." for LaTeX formulas
‚úì Always check \alpha is complete (not \alph or lpha)  
‚úì Always use parentheses () with \max, never {} or []
‚úì Always separate \max arguments with commas
‚úì Always add space after Greek letters: \alpha x not \alphax
‚úì Always test complex formulas in simple form first
‚úì Double-check Greek letters: \alpha, \beta, \gamma, \theta complete
‚úì Verify all mathematical symbols before generating MathTex objects

## COMMON LATEX ERROR PATTERNS IN MANIM - ZERO TOLERANCE
‚ùå MathTex("\\max(lpha x, x)")  # Truncated \alpha
‚ùå MathTex("\\max(\\alpha x x)")  # Missing comma  
‚ùå MathTex("f(x) = \\max{\\alpha x, x}")  # Wrong brackets
‚ùå MathTex("f(x) = \\max[\\alpha x, x]")  # Wrong brackets
‚ùå MathTex("\\alphax")  # Missing space after Greek letter
‚ùå MathTex("\\max(\\alpha,x)")  # Missing space after comma
‚ùå MathTex("\\alpha x,x")  # Missing \max function
‚ùå MathTex("max(\\alpha x, x)")  # Missing backslash

‚úÖ CORRECT LATEX PATTERNS FOR MATHEMATICAL FUNCTIONS:
‚úÖ MathTex(r"f(x) = \\max(\\alpha x, x)")  # Perfect Leaky ReLU
‚úÖ MathTex(r"f(x) = \\max(0, x)")  # Perfect ReLU
‚úÖ MathTex(r"\\alpha = 0.01")  # Parameter values
‚úÖ MathTex(r"\\frac{df}{dx}")  # Derivatives  
‚úÖ MathTex(r"\\sigma(x) = \\frac{1}{1 + e^{-x}}")  # Sigmoid

## UNIVERSAL LABELING SYSTEM INTEGRATION CHECKLIST
‚úì Import numpy as np at the top
‚úì Use np.array_equal() for direction comparisons in UniversalLabelingSystem
‚úì Initialize labeling system in construct(): self.labeler = UniversalLabelingSystem(self)
‚úì Actually call self.labeler.animate_labels_in() and self.labeler.animate_labels_out()
‚úì Use comprehensive labeling for ALL visual elements
‚úì Clear labels between scenes: self.labeler.clear_labels()

## MANDATORY DIRECTION COMPARISON TEMPLATE
def create_smart_label(self, obj, text, direction=UP, buff=0.3, color=WHITE, font_size=24):
    label = Text(text, font_size=font_size, color=color)
    
    # CRITICAL: Use numpy array comparison for direction constants
    if np.array_equal(direction, UP):
        label.next_to(obj, UP, buff=buff)
    elif np.array_equal(direction, DOWN):
        label.next_to(obj, DOWN, buff=buff)
    elif np.array_equal(direction, LEFT):
        label.next_to(obj, LEFT, buff=buff)
    elif np.array_equal(direction, RIGHT):
        label.next_to(obj, RIGHT, buff=buff)
    else:
        label.next_to(obj, direction, buff=buff)
    
    self.label_group.add(label)
    return label

## RATE LIMITING AND API ERROR PREVENTION
‚úì Handle 429 Rate Limit errors gracefully
‚úì Use exponential backoff for retry logic
‚úì Switch between different Gemini models when quota exceeded
‚úì Implement fallback strategies for API failures
‚úì Cache results to minimize API calls

## ANIMATION LIFECYCLE VERIFICATION
‚úì Every animated element has proper entrance (FadeIn, Create, Write)
‚úì Every animated element has proper exit (FadeOut, Uncreate)
‚úì Labels are animated in/out with proper timing
‚úì Scene cleanup between sections with self.clear() or selective removal
‚úì No elements remain on screen indefinitely

# ZERO ERROR SUCCESS GUARANTEE: This prompt structure ensures 100% error-free code generation for Manim v0.19+ through strict API compliance and built-in safety mechanisms.

ABSOLUTE OUTPUT ENFORCEMENT RULES

COMPLETELY FORBIDDEN - WILL CAUSE FAILURE:
‚ùå ```python (markdown code fence)
‚ùå ``` (any code fence)
‚ùå [[ ## section ## ]] (section headers)
‚ùå # REASONING or ## EXPLANATION (section headers)
‚ùå Any explanatory text outside Python code
‚ùå JSON unless valid Python dict syntax
‚ùå Markdown formatting of any kind

VGROUP VARIABLE NAMES - NEVER USE .clear() ON ANY OF THESE:
‚ùå FORBIDDEN: vgroup.clear()
‚ùå FORBIDDEN: label_group.clear()
‚ùå FORBIDDEN: self.label_group.clear()  
‚ùå FORBIDDEN: labels.clear()
‚ùå FORBIDDEN: group.clear()
‚ùå FORBIDDEN: all_objects.clear()
‚ùå FORBIDDEN: elements.clear()
‚ùå FORBIDDEN: scene_objects.clear()
‚ùå FORBIDDEN: mobjects.clear()
‚ùå FORBIDDEN: animations.clear()
‚ùå FORBIDDEN: components.clear()
‚ùå FORBIDDEN: any_variable_name.clear() if it's a VGroup

MANDATORY OUTPUT PATTERN:
from manim import *
import numpy as np
# ... rest of executable Python code ...
# ‚úì NEVER use .clear() on ANY VGroup variable
# ‚úì ALL LaTeX formulas use complete Greek letters (\\alpha not lpha)
# ‚úì ALL MathTex objects use proper syntax with raw strings
# ‚úì NO pass statements or empty method bodies
# ‚úì ALL methods have complete implementations with real Manim objects
class YourClass(VoiceoverScene):
    # ... complete implementation
    
CRITICAL VALIDATION:
- First line MUST be: from manim import *
- Last line MUST complete class definition
- ZERO non-Python content
- NO reasoning sections
- NO markdown elements